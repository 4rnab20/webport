---
title: "Pulsar Star Classification"
author: "Arnab Das"
date: "2021-05-1"
categories: [R]
output:
  html_document:
    css: styles.css
format:
  html:
    code-fold: true
    code-summary: "Show the code"
    code-tools: true
    code-block-bg: true
    code-block-border-left: "#31BAE9"
    toc: true
    toc-depth: 3
---

```{r, message=FALSE, warning = FALSE}
library(tidyverse)
library(dplyr)
library(kknn)
library(cowplot)
library(rsample)
library(themis)
library(parsnip)
library(tune)
library(workflows)
library(yardstick)
library(knitr)
```

## Introduction

Neutron stars are high-density celestial bodies caused by a large mass star collapsing on itself due to its own gravity (Goldberger, 2019). Pulsars are a classification of neutron stars which "pulse" or emit electromagnetic radiation periodically because of its high rotational velocity and strong magnetic fields. Telescopes on Earth can measure the continuous pulses of radio frequencies emitted by pulsars (Rodriguez, 2019). Identifying pulsar signals among interference and noise can be difficult, so machine learning can be used to predict target pulsars based on their recorded metrics.

Because the pulsar produces periodic pulsation signals they are often too weak to detect (Liu, 2017). Preprocessing this time series by folding the data with respect to the rotational period of the pulsar, yields a unique and distinguishable pulsar fingerprint referred to as an integrated pulse profile. The profile shape has an increased signal quality and form, and through long term observations are considered generally stable, as opposed to the highly variable single pulses (Liu, 2017).

However, before signals reach earth, they must pass through interstellar medium (ISM). This medium consists of everything that could possibly exist between a pulsar and the Earth (Liu, 2017). There are several major effects on pulsar radio signals, namely dispersion, scintillation, and scattering (Grootjans 2016), but for the purpose of this report only dispersion will be explored. The pulsar signal can be considered a plane wave whose frequency depends on interactions between ionized components of the ISM (Grootjans, 2016).The frequency dependence of these waves causes higher frequency waves to arrive earlier and lower frequency waves to arrive later, by an amount defined by a dispersion measure (DM) (Liu, 2017). The DM of any frequency is also proportional to the distance of the pulsar. All these factors result in the broadening and reducing the peak values for the frequency distribution curve of a pulsar. When a sufficient amount of dispersion is present in the signal, a signal-to-noise ratio (SNR) preprocessing (taking into consideration antenna aperture and other properties relevant to noise) must be applied to further analyze the pulsar curve by fitting the data (Grootjans, 2016). By applying this filter, a DM-SNR curve can be produced which has removed dispersion distortions in pulse shapes.

In the "Predicted Pulsar Star" Kaggle dataset, an integrated profile and a DM-SNR curve is considered. These two preprocessed measurements have tabulated results for the following statistics: mean, standard deviation, excess kurtosis, and skewness of these measurements. Excess kurtosis describes the tails on a normal distribution to measure the probability of events occurring outside of the normal range, unlike skewness which refers to the symmetry of a normal distribution. In our dataset, our target_class has been identified by binary classification, where a value of 1 represents a pulsar, and the value of 0 represents a non-pulsar.

In this project we will explore how a star's integrated and DM-SNR profiles affect the accuracy of K-Nearest Neighbors classification models based on these two profiles. The question we aim to answer is: can DM-SNR curve and integrated profile measurements predict pulsar stars? If so, which preprocessing technique yields the most accurate model? We hypothesize that the model built using DM-SNR curve measurements will yield the most accurate model, because it takes into account the noise of space, which is a common source of error when star signals are recorded.

## Methods and Results

We'll start by downloading the data set and reading it into a dataframe.

```{r, message=FALSE, warning = FALSE}

# Load training data from Kaggle
pulsar_data <- read_csv("pulsar_data_train.csv")

# Update column names to be more 'code-friendly'
colnames(pulsar_data) <- c("mean_integrated", "stdev_integrated", "kurtosis_integrated", "skew_integrated", "mean_DMSNR", "stdev_DMSNR", "kurtosis_DMSNR", "skew_DMSNR", "class")
# Covert target class to factor
pulsar_data <- pulsar_data %>% mutate(class=as_factor(class))

# Load testing file from Kaggle
pulsar_test_unclass <- read_csv("pulsar_data_test.csv")

#Update column names to be more 'code friendly'
colnames(pulsar_test_unclass) <- c("mean_integrated", "stdev_integrated", "kurtosis_integrated", "skew_integrated", "mean_DMSNR", "stdev_DMSNR", "kurtosis_DMSNR", "skew_DMSNR", "class")
summary(pulsar_test_unclass)
```

We can see that the test dataset doesn't have any target classes. So, this dataset is not useful to us in training/testing our model, and we will need to split the training dataset.

We will split the pulsar data set into training and testing sets. The testing set will not be touched until the model is ready for evaluation. We are splitting the data into 75% training and 25% testing because the dataset is sufficiently large (\~9,000 observations) that leaving 25% of the data for testing is enough to accurately assess the performance of our model.

```{r, message=FALSE, warning = FALSE}

# Split into training and testing set
set.seed(111)
# Determine how many rows have missing values.
num_rows_missing_values <- sum(apply(pulsar_data, 1, anyNA))
# Number of rows with missing values: 3183
# For our predictions down the road, we need to remove rows with NA values from the test set
pulsar_omit_na <- na.omit(pulsar_data) #this is so our KNN model will run properly later
pulsar_split <- initial_split(pulsar_omit_na, prop = 0.75, strata = class)
pulsar_train <- training(pulsar_split)
pulsar_test <- testing(pulsar_split)
```

### Exploratory Analysis

```{r, message=FALSE, warning = FALSE}
kable(head(pulsar_train))
```

There are eight predictive variables and one target variable. The predictors are composed of two groups of readings: the integrated profile and the DMSNR profile. Each group has the same four measurements: mean, standard deviation, kurtosis, and skew. We will use descriptive statistics and visualizations to explore the differences between the two profiles in order to determine which predictors will be most useful for our model.

```{r, message=FALSE, warning = FALSE}

# Calculate the number and percentage of observations that are pulsar stars.
num_obs <- nrow(pulsar_train)
class_dist <- pulsar_train %>% group_by(class) %>% summarize(n=n(), percentage=n()/num_obs*100)
class_dist
#class 0 (non-pulsar stars): 90.8% of the data
#class 1 (pulsar stars): 9.2% of the data
```

```{r, message=FALSE, warning = FALSE}

# We will also calculate the mean of the predictors in the dataset.
#mean of the predictors
predictor_means <- pulsar_train %>% select(-class) %>% map_df(~mean(., na.rm=TRUE))
predictor_means
#now, let's omit rows with NA values.
pulsar_train <- na.omit(pulsar_train)
```

The predictors' scale varies significantly, as evidenced by the calculated means. Since the k-nn classification algorithm is particularly sensitive to predictors with larger values, we need to scale and center the data before building the model. This ensures that predictors with larger values (e.g. mean of the integrated profile) don't have a disproportionate effect on the classification model.

### Data Visualization

Visualizing the data can give us an idea of the distribution of predictors, and may give us an indication of which predictors will be most useful in the creation of our model.

```{r, message=FALSE, warning = FALSE, fig.dim = c(20, 15)}

data_long <- pulsar_train %>%
pivot_longer(cols = -c(class, mean_integrated, stdev_integrated, kurtosis_integrated, skew_integrated), names_to = "Variable", values_to = "Value")
data_long$Variable <- str_replace(data_long$Variable, "_DMSNR", "")

options(repr.plot.width = 15, repr.plot.height = 10)
intdensity_plot <- ggplot(data_long, aes(x = Value, fill = Variable)) +
  geom_density(alpha = 0.7) +
  facet_wrap(~ Variable, scales = "free", nrow = 2, ncol = 2) +
  theme_minimal() +
  ggtitle("DMSNR") +
  theme(text = element_text(size = 15),
       axis.title.x = element_text(hjust = 1)) +
  guides(fill = "none") +
  scale_fill_manual(values = c("#e64186", "#672e8c", "#2d3569", "#c68dd8"))
                                                        
data_long1 <- pulsar_train %>%
  pivot_longer(cols = -c(class, mean_DMSNR, stdev_DMSNR, kurtosis_DMSNR, skew_DMSNR), names_to = "Variable", values_to = "Value")
data_long1$Variable <- str_replace(data_long1$Variable, "_integrated", "")

DMSNRdensity_plot <- ggplot(data_long1, aes(x = Value, fill = Variable)) +
  geom_density(alpha = 0.7) +
  facet_wrap(~ Variable, scales = "free", nrow = 2, ncol = 2) +
  theme_minimal() +
  ggtitle("Integrated") +
  theme(text = element_text(size = 15)) +
  ylab("") +
  xlab("") +
  scale_fill_manual(values = c("#e64186", "#672e8c", "#2d3569", "#c68dd8"), labels = c("Kurtosis", "Mean", "Skewness", "Standard Deviation"))

combine_plot <- plot_grid(intdensity_plot, DMSNRdensity_plot, nrow = 1, ncol = 2)
plot_grid(ggdraw() + draw_label("Density plots", fontface='bold', size = 25), combine_plot, ncol=1, rel_heights=c(0.1, 1))
```

These distributions provide insights into the characteristics of the data for each variable, including the presence of outliers, the symmetry of the data, and the concentration of values. The skewness and kurtosis specifically provide information about the shape of the distribution, which can be useful in understanding the underlying patterns in the data.

```{r, message=FALSE, warning = FALSE, fig.dim = c(20, 15)}

# To visualize the distribution of pulsar vs non-pulsar stars, we can use a bar chart.
class_plot <- subset(class_dist, !is.na(class)) %>% ggplot(aes(x=class, y=n, fill=class)) +
  geom_bar(stat="identity") +
  ylab("Count") +
  xlab("Class")+
  labs(title="Frequencies of target classes") +
  theme_classic()+
  theme(text=element_text(size=20)) +
  scale_fill_brewer(palette = "Purples", labels = c("0" = "non-pulsar", "1" = "pulsar"))
class_plot
```

There are significantly more observations in the non-pulsar (0) than pulsar (1) class. Imbalanced data can result in the model inappropriately preferring the more common class. In order to account for this imbalance, we will need to upsample the pulsar class to produce an accurate model (see methods for more details on how this is done).

To visualize the relationship between predictors and the target class, we can create violin plots of each predictor variable stratified by target class. Unlike boxplots, violin plots allow us to visualize both the distribution and density of the underlying data. This additional detail about the data will help with our intuition when it comes to selecting predictors for our model.

Using those plots, we can see which predictors vary most between the two target classes, and between integrated and DM-SNR.

The data needs to be tidied before the violin plots can be created. Specifically, we will be moving the values of each of the predictors from their own columns into key-value pairs using the gather function.

```{r, message=FALSE, warning = FALSE}

tidy_stars <- pulsar_train %>%
gather(key=profile, value=value, mean_integrated, stdev_integrated, kurtosis_integrated, skew_integrated,
mean_DMSNR, stdev_DMSNR, kurtosis_DMSNR, skew_DMSNR)
kable(head(tidy_stars))
```

```{r, message=FALSE, warning = FALSE, fig.dim = c(15, 10)}

  # make violin plots comparing DM-SNR Curve and Integrated Profile variables, to see how they differ
  # between our target classes
  # tidy the data to generate a profile column

# mean violin
mean_violin <-  tidy_stars %>%
  filter(profile=="mean_integrated"|profile=="mean_DMSNR")%>%
  ggplot(aes(x=profile, y=value), trim=TRUE)+
  geom_violin(aes(fill=class), draw_quantiles=c(0.5), colour = "red")+
  xlab("Target class") +
  ylab("Mean Value")+
  labs(fill="Class", title="Mean")+
  theme_minimal()+
  theme(text=element_text(size=20)) +
  scale_fill_brewer(palette = "Reds", labels = c("0" = "non-pulsar", "1" = "pulsar"))

# sd violin
  sd_violin <-  tidy_stars %>%
  filter(profile=="stdev_integrated"|profile=="stdev_DMSNR")%>%
  ggplot(aes(x=profile, y=value), trim=TRUE)+
  geom_violin(aes(fill=class), draw_quantiles=c(0.5), colour = "purple")+
  xlab("Profile") +
  ylab("SD Value")+
  labs(fill="Class", title="Standard Deviation")+
  theme_minimal()+
  theme(text=element_text(size=20)) +
  scale_fill_brewer(palette = "PuRd", labels = c("0" = "non-pulsar", "1" = "pulsar"))

# kurtosis violin
kurtosis_violin <-  tidy_stars %>%
  filter(profile=="kurtosis_integrated"|profile=="kurtosis_DMSNR")%>%
    ggplot(aes(x=profile, y=value))+
  geom_violin(aes(fill=class), draw_quantiles=c(0.5), colour = "blue")+
  xlab("Profile") +
  ylab("Kurtosis Value")+
  labs(fill="Class", title="Kurtosis")+
  theme_minimal()+
  theme(text=element_text(size=20)) +
  scale_fill_brewer(palette = "Blues", labels = c("0" = "non-pulsar", "1" = "pulsar"))

# skew_violin
skew_violin <-  tidy_stars %>%
  filter(profile=="skew_integrated"|profile=="skew_DMSNR")%>%
  ggplot(aes(x=profile, y=value), draw_quantiles=c(0.5))+
  geom_violin(aes(fill=class), colour = "darkgreen")+
  xlab("Profile") +
  ylab("Skew Value")+
  labs(fill="Class", title="Skew")+
  theme_minimal()+
  theme(text=element_text(size=20)) +
  scale_fill_brewer(palette = "Greens", labels = c("0" = "non-pulsar", "1" = "pulsar"))

combined_plot <- plot_grid(mean_violin, sd_violin, kurtosis_violin, skew_violin, nrow = 2, ncol = 2)
plot_grid(ggdraw() + draw_label("Class Across Key Factors", fontface='bold', size = 25), combined_plot, ncol=1, rel_heights=c(0.1, 1))
```

Figures 2-5 are violin plots of the four types of measurements that were collected (mean, standard deviation, kurtosis, and skew), stratified by target class and profile (integrated vs DMSNR). These plots allow us to determine which predictors will be most useful for building our classification model.

Firstly, it demonstrates how the predictors vary between the two target classes. A predictor whose distribution varies significantly between the target classes (for example, in Figure 3), is likely to be more useful for our classification model than a predictor with very similar distributions.

Secondly, these plots demonstrate the difference between the integrated and DMSNR profiles. We can see which profile varies more between the two target classes, thus allowing us to predict which profile will be more useful for building classification models.

We can see that while each predictor is extremely different depending on whether it is from the integrated or DM-SNR profile, all groups show a difference in the distribution and mean of the target classes within the same variable. So, each would be a useful addition to their respective models. As well, from a broader perspective, we want to use all of the scientific data available to us, since it was painstakingly collected and cleaned, and omission of a particular variable without reasonable grounds could cause us to lose accuracy in our models.

### K-Nearest Neighbors Analysis

After our preliminary analysis, our next step will be to use our integrated and DM-SNR variables to predict pulsar stars using the K-Nearest Neighbors classification algorithm.

This will help us determine whether one of these two recording techniques is better than the other at distinguishing pulsar stars from the noise of space.

Our first step is to set up our KNN model, using the integrated variables. We will do this in several steps. 1. Make a recipe. The recipe will preprocess our data by centering and scaling our predictors (since the ranges of our predictors differ), and upsample our target class (since it is \~90% target class 0). 2. Make a KNN spec, to tell the computer to run KNN (and with what parameters). This will include the neighbors=tune() function so we can find the value of K that gives us the highest accuracy. 3. Make our cross validation sets, so we can test our tuning model and find accuracies of different K's. 4. Make a tuning workflow, to tune the KNN model and find the value of K giving the highest accuracy.

```{r, message=FALSE, warning = FALSE}

#1. First, we make our recipe, which will preprocess our data.
recipe_integrated <- recipe(class ~ mean_integrated + stdev_integrated + kurtosis_integrated +
skew_integrated, data = pulsar_train) %>%
    step_scale(all_predictors()) %>%
    step_center(all_predictors())%>%
    step_upsample(class, over_ratio=1, skip=TRUE)

recipe_integrated
```

```{r, message=FALSE, warning = FALSE}

#2. Next, we will create our model, so the computer knows how to run the KNN
knn_tune <- nearest_neighbor(weight_func = "rectangular", neighbors = tune()) %>%
            set_engine("kknn") %>%
            set_mode("classification")
```

```{r, message=FALSE, warning = FALSE}

#3. next, we make our cross-validation set to test iterations of K
vfold <- vfold_cv(pulsar_train, v = 5, strata = class)

#4. now, we make a workflow to find the best value of K, to give our training model the best accuracy.
knn_fit <- workflow() %>%
        add_recipe(recipe_integrated) %>%
        add_model(knn_tune) %>%
        tune_grid(resamples = vfold, grid = 20) %>%
        collect_metrics()
        #note: grid=20 to test 20 values of K, rather than the usual 10
        #This is so we can confidently find the value of K with the highest accuracy by being more rigorous with our testing

```

Now that our model has been tuned, we can pull the accuracy of our tuning model for each iteration of K, and plot it to show how accuracy changes depending on K.

```{r, message=FALSE, warning = FALSE}

#pull accuracies
accuracies <- knn_fit %>%
       filter(.metric == "accuracy")
#plot accuracy against K
cross_val_plot <- ggplot(accuracies, aes(x = neighbors , y = mean)) +
       geom_point() +
       geom_line() +
       labs(x = "Neighbours", y = "Accuracy Estimate", title = "Integrated profile model accuracy")  +
       theme(text = element_text(size = 20))

cross_val_plot
```

According to the plot above, the value of K that gives the highest accuracy is K=2. We will now make another model that uses this value of K to predict the class of a testing set. This will require us to make a new KNN spec and workflow- but we can reuse our old recipe, since it isn't affected by choosing K.

```{r, message=FALSE, warning = FALSE}

#pull the value of K giving the highest accuracy (2)
kn_integrated <- knn_fit %>%
       filter(.metric == "accuracy") %>%
       arrange(desc(mean)) %>%
       head(1) %>%
       pull(neighbors)
kn_integrated
```

```{r, message=FALSE, warning = FALSE}

#make another KNN spec, this time with neighbors= our chosen value of K
int_spec <- nearest_neighbor(weight_func = "rectangular", neighbors = kn_integrated) %>%
              set_engine("kknn") %>%
              set_mode("classification")
#make the workflow to build our final model
int_fit <- workflow() %>%
             add_recipe(recipe_integrated) %>%
             add_model(int_spec) %>%
             fit(data = pulsar_train)
```

Now that we've build our final model, we can test it using data it hasn't seen before, i.e. our testing set. This will tell us its overall accuracy in predicting the class of an unknown star, and how good it is at predicting pulsar stars specifically. Once we have predicted the testing set, we can gather its metrics to see its accuracy, and plot it as a confusion matrix to see how many times it predicted each class correctly, and incorrectly.

```{r, message=FALSE, warning = FALSE}

#predict the testing set using our integrated model
int_pred <- predict(int_fit, pulsar_test) %>% bind_cols(pulsar_test)
#get the accuracy of our model at predicting the test class
int_metrics <- int_pred %>% metrics(truth = class, estimate=.pred_class)

# Generate confusion matrix
int_mat <- int_pred %>%
  conf_mat(truth = class, estimate = .pred_class)

# Convert confusion matrix to data frame
int_mat_df <- as.data.frame(int_mat$table)

# Plot the confusion matrix using ggplot2
ggplot(int_mat_df, aes(x = Truth, y = Prediction, fill = factor(Freq))) +
  geom_tile(color = "white") +
  geom_text(aes(label = Freq), vjust = 1) +
  labs(title = "Confusion Matrix",
       x = "Predicted Class",
       y = "True Class",
       fill = "Frequency") +
  theme_minimal() +
  guides(fill = "none") +
  scale_fill_brewer(palette = "Blues")

tidy_int_mat <- tidy(int_mat) #this is for later
```

We are finished with our integrated model, and can begin making our DM-SNR model. This will follow the same steps as above. Firstly, we will set up a recipe to tune the value of K to that which gives the highest accuracy of our training model. To do this, we will: 1. Make a new recipe. 2. Reuse our old KNN spec (since it doesn't depend on our variables) 3. Reuse our old cross validation sets (since they don't depend on our variables) 4. Make a tuning workflow, to find the best value of K.

```{r, message=FALSE, warning = FALSE}

#make the recipe
recipe_DMSNR <- recipe(class ~ mean_DMSNR + stdev_DMSNR + kurtosis_DMSNR +
skew_DMSNR, data = pulsar_train) %>%
    step_scale(all_predictors()) %>%
    step_center(all_predictors())%>%
    step_upsample(class, over_ratio=1, skip=TRUE)

#reuse KNN spec and cross validation sets
#make our tuning workflow
knn_fit <- workflow() %>%
        add_recipe(recipe_DMSNR) %>%
        add_model(knn_tune) %>%
        tune_grid(resamples = vfold, grid = 20) %>% #note: grid=20 to test 20 values of K, rather than the usual 10
        collect_metrics()

```

With our DM-SNR tuning workflow, we can pull the accuracies of each K in our tuning model, and plot them to see how accuracy depends on K.

```{r, message=FALSE, warning = FALSE}

#pull accuracies
accuracies <- knn_fit %>%
       filter(.metric == "accuracy")
#make the plot
cross_val_plot <- ggplot(accuracies, aes(x = neighbors , y = mean)) +
       geom_point() +
       geom_line() +
       labs(x = "Neighbours", y = "Accuracy Estimate", title = "DM-SNR profile model accuracy")  +
       theme(text = element_text(size = 20))

cross_val_plot
```

The plot tells that the value of K giving the highest accuracy of our training model is K=1. We will pull that value, and use it to build a new model to predict our testing set (and other unknown stars). We can reuse our old recipe and build a new KNN spec for our best value of K (value of K giving the highest accuracy), and a new workflow for our final DM-SNR model.

```{r, message=FALSE, warning = FALSE}

kn_DMSNR <- knn_fit %>%
       filter(.metric == "accuracy") %>%
       arrange(desc(mean)) %>%
       head(1) %>%
       pull(neighbors)

#make new KNN spec with best value of K
DMSNR_int_spec <- nearest_neighbor(weight_func = "rectangular", neighbors = kn_DMSNR) %>%
              set_engine("kknn") %>%
              set_mode("classification")
#make final workflow
DMSNR_int_fit <- workflow() %>%
             add_recipe(recipe_DMSNR) %>%
             add_model(DMSNR_int_spec) %>%
             fit(data = pulsar_train)
```

Now that our final DM-SNR model is built, we will test it on data it hasn't seen before (the testing set) to find its accuracy. We can pull the overall accuracy of the model using the metrics() function, and use a confusion matrix to show how many times our model correctly and incorrectly identified the class of the stars by comparing their true and predicted class.

```{r, message=FALSE, warning = FALSE}

#Predict the testing data
DMSNR_int_pred <- predict(DMSNR_int_fit, pulsar_test) %>%
                    bind_cols(pulsar_test)
#get the accuracy of our model at predicting the classes of the test data
DMSNR_int_metrics <- DMSNR_int_pred %>%
metrics(truth = class, estimate=.pred_class)

#make a confusion matrix
DMSNR_mat <- DMSNR_int_pred %>%
      conf_mat(truth = class, estimate = .pred_class)

# Convert confusion matrix to data frame
DMSNR_mat_df <- as.data.frame(DMSNR_mat$table)

# Plot the confusion matrix using ggplot2
ggplot(DMSNR_mat_df, aes(x = Truth, y = Prediction, fill = factor(Freq))) +
  geom_tile(color = "white") +
  geom_text(aes(label = Freq), vjust = 1) +
  labs(title = "Confusion Matrix",
       x = "Predicted Class",
       y = "True Class",
       fill = "Frequency") +
  theme_minimal() +
  guides(fill = "none") +
  scale_fill_brewer(palette = "Purples")

tidy_DMSNR_mat <- tidy(DMSNR_mat)#this is for later
```

Finally, to display our data we will make a grouped bar chart, showing both the overall accuracy and the accuracy of predicting pulsar stars (the true positive rate). It is important for us to look at overall accuracy and pulsar star classification accuracy because while we do want a model that has a high overall accuracy, our goal is to find the model that is the best at predicting pular stars (not just non-pulsars), so we need to compare both metrics of our models. We will also calculate a false positive rate, as the goal of our project is to correctly identify pulsar stars - so while a false negative (classifying a pulsar as a non-pulsar star) is not ideal, it is not as detrimental as false positives (classifying a non-pulsar as a pulsar) as this affects our ability to gain accurate knowledge on pulsar stars using our model.

```{r, message=FALSE, warning = FALSE}

#gather the values from our accuracy estimates
#gather overall accuracy estimates from our two models
DMSNR_accuracy <- as.numeric(DMSNR_int_metrics[1, 3])*100 #92.3%
integrated_accuracy <- as.numeric(int_metrics[1, 3])*100 #96.8%

#gather accuracy estimates of pulsar stars only from our confusian matrices
#this is correctly identified pulsars/ total number of true pulsars *100
pulsar_integrated <- as.numeric(tidy_int_mat[4,2])/
(as.numeric(tidy_int_mat[3,2])+as.numeric(tidy_int_mat[4,2]))*100
pulsar_integrated #77.5%
pulsar_DMSNR <- as.numeric(tidy_DMSNR_mat[4,2])/
(as.numeric(tidy_DMSNR_mat[3,2])+as.numeric(tidy_DMSNR_mat[4,2]))*100
pulsar_DMSNR #58.0%

#gather accuracy estimates of pulsar stars from confusion matrix
#calculate false positive rate
#this is false positive rate (0's classified as 1)/total negatives (all 0's) *100
integrated_falsepos <- as.numeric(tidy_int_mat[2, 2])/
(as.numeric(tidy_int_mat[1, 2])+as.numeric(tidy_int_mat[2, 2]))*100
integrated_falsepos #1.2%
DMSNR_falsepos <- as.numeric(tidy_DMSNR_mat[2,2])/
((as.numeric(tidy_DMSNR_mat[1,2])+as.numeric(tidy_DMSNR_mat[2,2])))*100
DMSNR_falsepos #4.2%
```

Now we can plot our accuracy estimates as a grouped bar chart.

```{r, message=FALSE, warning = FALSE, fig.dim = c(15, 10)}

#make a new dataframe for our plot
accuracies <- data.frame("percent_accuracy"=c(DMSNR_accuracy, integrated_accuracy, pulsar_integrated, pulsar_DMSNR))
names <- data.frame("type"=c("DMSNR", "Integrated", "Integrated", "DMSNR"))
subgroup <- data.frame("subgroup"=c("Overall Accuracy", "Overall Accuracy", "Pulsar Identification Accuracy", "Pulsar Identification Accuracy"))
accuracy_table <- bind_cols(names, accuracies, subgroup)

#make the plot
accuracy_plot <- ggplot(accuracy_table, aes(x=type, y=percent_accuracy, fill=subgroup))+
geom_bar(aes(fill=subgroup),stat="identity", position="dodge")+
  labs(x="Type of Star Recording", y="Percent Accuracy of KNN Model", fill="Accuracy Type", title="Overall and true positive accuracy")+
  theme_classic()+
theme(text = element_text(size=20)) +
scale_fill_brewer(palette = "BuGn")


accuracy_plot
```

From this barchart, we observe that the overall accuracy and accuracy of pulsar star identification differs between our two models. In both, the integrated model shows higher accuracy.

## Discussion

We created two models using the provided metrics for the integrated and DM-SNR profiles. The first model using integrated profile predictors yielded an accuracy of 96% for all predicted classes. The second model using the DM-SNR curve predictors had a lower accuracy at 91% for all predicted classes. In addition to better overall accuracy, the integrated curve model was also more accurate when predicting true positives (i.e. correctly identifying pulsar stars). Out of 219 pulsar stars in our data set, the integrated curve model correctly identified 178 (78%), compared with the DM-SNR curve model which only identified 127 (58%). Clearly, the integrated model is better than the DM-SNR curve model at predicting pulsar stars from the noise of space. However, considering how rare pulsar stars are an 81% accuracy of our best model may not be good enough if it is to be used in scientific research. To elucidate this, we calculated a false positive rate for each model, as falsely identifying a non-pulsar as a pulsar star affects the quality of future research far more than missing a pulsar star due to a false negative. Our integrated model had a false positive rate of 1.2%, while our DM-SNR model had a false positive rate of 4.2%. So again we see our integrated model is better at distinguishing pulsar stars, would give better prediction accuracy for our key metrics, and is a better choice for use in classifying new stars.

By predicting the target class for each observation in the testing data set using the integrated model, we accurately differentiated pulsars from non-pulsars for each observation in the testing data set and could predict the class of recently recorded pulsar observations.

Contrary to our hypothesis that the DM-SNR curve model would be more accurate, the integrated profile model proved to be better at predicting pulsars. The reasoning for our hypothesis was that the DM-SNR curve would be a better preprocessing method which removed distortions in pulse shapes due to dispersion, in comparison to the integrated pulse profile which preprocessed the time series by folding the data with respect to the rotational period. Analyzing the integrated vs DM-SNR model's accuracies tells us how well these recording methods can identify a pulsar star and the best variables for filtering pulsar stars from the noise of space. We used the integrated model to predict the target class for the observations in the testing dataset, differentiating pulsar stars from non-pulsars. Prediction of pulsars will be beneficial for scientists and astronomers for celestial research. Using pulsar stars, scientists can measure cosmic distances, time and search for planets beyond Earth's solar system. Moreover, it is possible to measure how the presence of massive bodies curves space-time. By observing pulsars, the researchers have shown repeatedly that close double neutron star systems send out strong gravitational waves (Cofield 2016). Helping scientists efficiently and accurately identify pulsar stars will ultimately help advance research areas that depend on pulsar stars.

Now that we have demonstrated a reasonably effective model using the provided data set, the next step would be to test our model out in the real world. This will give us a better idea of how useful our model might actually be to scientists interested in identifying pulsar stars, as the competition data set we used for our model may not be entirely representative of the data typically produced by radio telescopes. We may find that additional cleaning or wrangling is needed in order to deploy our model on real-world data.

At the end of the data analysis, several questions may arise: - Are either of our models accurate enough for scientific research? - Is another classification model better suited to this data (e.g. Random Forest)? - Which predictors need more scientific advancement until they are as useful as the others? - Our best values of K were quite low. Do we need to omit variables that are adding extra variation into our models? - How accurate are the predicted labels from the model? - Can we further improve the model or method of classification?

## Works cited

Cofield,C.(2016, April 22). What Are Pulsars? . https://www.space.com/32661-pulsars.html

Grootjans et al. (2016, August). Detection of Dispersed Pulsars in a Time Series by Using a Matched Filtering Approach. https://essay.utwente.nl/71435/1/GROOTJANS_MA_EWI.pdf

Goldberger, A. (2019, January 04). Classifying pulsar stars using AI techniques. https://medium.com/duke-ai-society-blog/classifying-pulsar-stars-using-ai-techniques-d2be70c0f691

Max Planck Institute, PULSE: The Impact of European Pulsar Science on Modern Physics, https://phys.org/news/2005-12-pulse-impact-european-pulsar-science.html

(n.d.). Ggplot2 violin plot : Quick start guide - R software and data visualization. STHDA. http://www.sthda.com/english/wiki/ggplot2-violin-plot-quick-start-guide-r-software-and-data-visualization

(n.d.). Violin Plot. Ggplot 2. https://ggplot2.tidyverse.org/reference/geom_violin.html

Rodriguez, F. (2019, October 07). Pulsar Stars Detection. https://datauab.github.io/pulsar_stars/

Liu K., (2017, June 26).Introduction to Pulsar, Pulsar Timing, and measuring of Pulse Time-of-Arrivals. http://ipta.phys.wvu.edu/files/student-week-2017/IPTA2017_KuoLiu_pulsartiming.pdf
